1️⃣ PRISMA MODELS + RELATIONS (FINALIZED, ENFORCEMENT-READY)

You already have the core schema. The following three additions are REQUIRED to make enforcement deterministic, auditable, and regulator-safe.

1.1 REQUIRED ADDITIONS TO schema.prisma
A. Certification Enforcement State (Persisted, Derived)

Why this exists

Prevents inconsistent recalculation during audits

Freezes the evaluated compliance state at a point in time

Supports fail-closed enforcement

model CertificationEnforcement {
  id               String   @id @default(uuid())
  certificationId  String   @unique
  isBlocked        Boolean  @default(false)
  blockedReason    String?
  evaluatedAt      DateTime @default(now())

  certification Certification
    @relation(fields: [certificationId], references: [id], onDelete: Restrict)
}


Hard rules:

Written only by enforcement logic

Never edited by UI

Never deleted

Re-evaluation creates a new record only if design later requires history
(for now: single authoritative row)

B. Generic Evidence Linking (Many-to-Many, Cross-Entity)

Why this exists

Allows any entity to pull evidence without hard FK coupling

Preserves evidence graph flexibility

Avoids schema churn as system expands

model EntityEvidenceLink {
  id             String   @id @default(uuid())
  entityType     String
  entityId       String
  evidenceNodeId String

  evidenceNode EvidenceNode
    @relation(fields: [evidenceNodeId], references: [id], onDelete: Restrict)

  @@index([entityType, entityId])
}


Hard rules:

No deletes

No updates

Links are append-only

EvidenceNode is the immutable source of truth

C. Enforcement Actions (Auditable Control Plane)

Why this exists

Makes enforcement visible, reviewable, and defensible

Separates decision from evidence

Supports legal review and regulator inspection

model EnforcementAction {
  id            String           @id @default(uuid())
  actionType    EnforcementType
  targetType    String
  targetId      String
  reason        String
  triggeredBy   String           // "system" | userId
  createdAt     DateTime         @default(now())
}

enum EnforcementType {
  certification_block
  work_window_block
  jha_block
}


Hard rules:

EnforcementAction is never deleted

Every block must have:

reason

target

timestamp

UI displays these read-only

2️⃣ OPENAPI (SWAGGER) SPEC — CONTRACT LEVEL (LOCKED)

This is not documentation fluff.
This is a binding contract between UI, backend, and auditors.

2.1 OPENAPI HEADER
openapi: 3.0.3
info:
  title: Unified System of Proof API
  version: 1.0.0
  description: Audit-defensible safety, compliance, and verification platform
servers:
  - url: https://api.yourplatform.com

2.2 SECURITY SCHEMES
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT


Rules:

Public QR routes do NOT use bearerAuth

All mutation routes REQUIRE bearerAuth

2.3 CORE SCHEMAS (AUTHORITATIVE)
Employee
Employee:
  type: object
  properties:
    id:
      type: string
    firstName:
      type: string
    lastName:
      type: string
    tradeRole:
      type: string
    status:
      type: string
      enum: [active, inactive]

Certification
Certification:
  type: object
  properties:
    id:
      type: string
    employeeId:
      type: string
    certificationType:
      type: string
    issuingAuthority:
      type: string
    issueDate:
      type: string
      format: date
    expirationDate:
      type: string
      format: date
    status:
      type: string
      enum: [valid, expiring, expired, revoked]

QR Verification Response (PUBLIC)
VerificationResponse:
  type: object
  properties:
    employeeName:
      type: string
    certificationType:
      type: string
    status:
      type: string
      enum: [valid, expired, revoked]
    issuingAuthority:
      type: string
    verifiedAt:
      type: string
      format: date-time


Hard rules:

Public response is read-only

No internal IDs leaked

No mutation possible

2.4 CRITICAL ENDPOINTS (ENFORCEMENT-AWARE)
Public QR Verification
/api/verify/{token}:
  get:
    summary: Verify certification via QR code
    parameters:
      - name: token
        in: path
        required: true
        schema:
          type: string
    responses:
      "200":
        description: Verification result
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/VerificationResponse"


Rules:

Creates VerificationEvent

Writes evidence

Does NOT mutate certification

Create Certification (Authenticated)
/api/employees/{employeeId}/certifications:
  post:
    security:
      - bearerAuth: []
    summary: Issue certification to employee
    responses:
      "201":
        description: Certification created


Rules:

Uses withEvidence()

Creates Certification + Enforcement state

Appends ledger entry

Work Window Creation (Enforced)
/api/work-windows:
  post:
    security:
      - bearerAuth: []
    summary: Create work window (cert enforcement applied)
    responses:
      "201":
        description: Work window created
      "403":
        description: Blocked due to certification enforcement


Rules:

Enforcement evaluated before creation

Blocked state must write EnforcementAction

Fail-closed behavior only
