1) PRISMA MIGRATIONS (AUTHORITATIVE)
1.1 Migration Strategy

Linear, append-only migrations

No destructive changes (audit defensibility)

Backfill jobs for derived/enforcement tables

DB-level constraints to prevent silent corruption

Migration Order

Core identity & orgs

Employees, crews

Certifications + QR

Evidence & ledger

Safety, field ops

Incidents & costs

AI + enforcement helpers

Indexing & constraints

1.2 Example Migrations
001_init_core.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  type TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id),
  email TEXT UNIQUE NOT NULL,
  role TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT now()
);

002_employees_certifications.sql
CREATE TABLE employees (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id),
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  trade_role TEXT,
  status TEXT NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE certifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  employee_id UUID REFERENCES employees(id),
  certification_type TEXT NOT NULL,
  issuing_authority TEXT NOT NULL,
  issue_date DATE NOT NULL,
  expiration_date DATE NOT NULL,
  status TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

003_qr_verification.sql
CREATE TABLE verification_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  certification_id UUID REFERENCES certifications(id),
  token_hash TEXT UNIQUE NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE verification_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  verification_token_id UUID REFERENCES verification_tokens(id),
  scanned_at TIMESTAMPTZ DEFAULT now(),
  verification_result TEXT NOT NULL
);

004_evidence_ledger.sql
CREATE TABLE evidence_nodes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  entity_type TEXT NOT NULL,
  entity_id UUID NOT NULL,
  actor_type TEXT NOT NULL,
  actor_id UUID NOT NULL,
  timestamp TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE immutable_event_ledger (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  evidence_node_id UUID REFERENCES evidence_nodes(id),
  event_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

2) SERVICE-LAYER LOGIC (CORE BUSINESS RULES)

All services are server-only, never in UI.

2.1 Certification Enforcement Service
export async function enforceEmployeeEligibility(
  employeeId: string,
  requiredCerts: string[]
) {
  const certs = await prisma.certification.findMany({
    where: { employeeId }
  });

  for (const required of requiredCerts) {
    const valid = certs.find(
      c => c.certificationType === required && c.status === 'valid'
    );

    if (!valid) {
      await recordEnforcementAction({
        type: 'certification_block',
        targetId: employeeId,
        reason: `Missing required cert: ${required}`
      });

      throw new ForbiddenError('Employee not eligible');
    }
  }
}

2.2 QR Verification Service (Public, Immutable)
export async function verifyCertificationByQR(token: string) {
  const hashed = hashToken(token);

  const qr = await prisma.verificationToken.findUnique({
    where: { tokenHash: hashed },
    include: { certification: true }
  });

  if (!qr) throw new NotFoundError();

  const status = qr.certification.status;

  await prisma.verificationEvent.create({
    data: {
      verificationTokenId: qr.id,
      verificationResult: status
    }
  });

  await writeEvidence('qr_scan', qr.certification.id);

  return {
    certificationType: qr.certification.certificationType,
    status,
    verifiedAt: new Date()
  };
}

2.3 Audit Defense Aggregation Service
export async function buildAuditTimeline(auditId: string) {
  return prisma.evidenceNode.findMany({
    where: {
      id: {
        in: (
          await prisma.auditEvidenceLink.findMany({
            where: { auditCaseId: auditId },
            select: { evidenceNodeId: true }
          })
        ).map(e => e.evidenceNodeId)
      }
    },
    orderBy: { timestamp: 'asc' }
  });
}

3) NEXT.JS APP ROUTER STRUCTURE

This strictly separates platform, public verification, and regulator access.

app/
├─ api/
│  ├─ employees/
│  │  ├─ route.ts
│  │  └─ [employeeId]/
│  │     └─ certifications/route.ts
│  ├─ certifications/
│  │  └─ [certId]/qr/route.ts
│  ├─ verify/
│  │  └─ [token]/route.ts          # PUBLIC QR
│  ├─ audits/
│  │  └─ [auditId]/export/route.ts
│  └─ incidents/
│     └─ route.ts
│
├─ (platform)/
│  ├─ people/
│  │  └─ employees/
│  │     └─ [id]/page.tsx
│  ├─ safety/jha/
│  ├─ operations/work-windows/
│  ├─ incidents/
│  └─ compliance/audit-vault/
│
├─ (public)/
│  └─ verify/
│     └─ [token]/page.tsx           # Read-only
│
├─ (regulator)/
│  └─ audit/
│     └─ [sessionId]/page.tsx
│
├─ lib/
│  ├─ services/
│  │  ├─ certification.ts
│  │  ├─ qr.ts
│  │  ├─ audit.ts
│  │  └─ evidence.ts
│  ├─ middleware/
│  │  ├─ auth.ts
│  │  ├─ org-scope.ts
│  │  └─ evidence-writer.ts
│  └─ ai/
│     └─ risk-engine.ts

4) INDEXES, CONSTRAINTS & SCALING STRATEGY
4.1 Critical Indexes (NON-OPTIONAL)
CREATE INDEX idx_cert_employee_status
  ON certifications(employee_id, status);

CREATE INDEX idx_qr_token_hash
  ON verification_tokens(token_hash);

CREATE INDEX idx_verification_events_token
  ON verification_events(verification_token_id);

CREATE INDEX idx_evidence_entity
  ON evidence_nodes(entity_type, entity_id);

CREATE INDEX idx_ledger_created_at
  ON immutable_event_ledger(created_at);

4.2 Constraints

No DELETE on:

certifications

verification_events

evidence_nodes

immutable_event_ledger

Enforce via:

DB roles (no delete grants)

Prisma middleware rejecting deletes

4.3 Scaling Strategy
Phase 1 (MVP / Pilot)

Single Postgres primary

Read replicas for audits

Background jobs via queue (BullMQ)

Phase 2 (Enterprise)

Evidence + Ledger moved to partitioned tables

Time-based partitioning on created_at

Hot/cold storage split (ledger never changes)

Phase 3 (Regulatory Scale)

Append-only ledger replicated to:

Immutable object storage (WORM)

Optional blockchain anchoring (hash only)

FINAL STATE CHECK

At this point you have:

✅ Schema

✅ Migrations

✅ APIs

✅ Enforcement logic

✅ QR verification

✅ AI hooks

✅ App Router layout

✅ Audit-grade constraints

✅ Scaling plan

This is production architecture, not a prototype.
